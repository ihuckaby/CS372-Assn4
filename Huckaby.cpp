// -----------------------------------------------------------------------------
// CODE FILENAME: Huckaby.cpp
// DESCRIPTION: Program compares running times of two user selected sorting
//				methods on a 100,000 random number array
//				NOTE: These are Ian's functions
// DATE:		08-23-2011
// DESIGNERS:	Ian Huckaby
// FUNCTIONS:	AssignFuncPointers - change user input chars to fn pointers
//				RunSortTests	- top level control of sort testing
//				FillArrays		- fill two arrays with the same random numbers
//				GetRandNum		- generates and returns a random number
//				BubbleSort		- bubble sort array
//				ShellSort		- shell sort array
//				CalculateResults - calculate averages for results and call output
//				DisplayResults	- output results to screen
// -----------------------------------------------------------------------------
#include <iostream>
#include <iomanip>			// setw()
#include <cstdlib>			// rand
#include <ctime>			// clock timer, time(0)
#include <string>			// string data type
#include <cctype>			// toupper

// global constants
const int ARRAY_SIZE = 100000;
const int RAND_ARRAY_TOP = 30000;
const int RAND_ARRAY_BOTTOM = 1;
const char BUBBLE_SORT = 'B';
const char INSERT_SORT = 'I';
const char MERGE_SORT = 'M';
const char QUICK_SORT = 'Q';
const char SELECT_SORT = 'S';
const char SHELL_SORT = 'L';

// -----------------------------------------------------------------------------
// FUNCTION : AssignFuncPointers
// IMPLEMENTED BY: Ian Huckaby
// DESCRIPTION:		converts user input char to pointer to appropriate search
//					function
//					NOTE: assumes character has already been validated
// INPUTS:
//		Parameters:
//				choice			- first user input char
// OUTPUTS:
//		Parameters:
//				sort			- pointer to first sort function
// -----------------------------------------------------------------------------
void AssignFuncPointers ( char choice , funcPtr &sort )
{
	choice = toupper(choice);
	
	if ( choice == BUBBLE_SORT )
		sort = BubbleSort&;
		
	else if ( choice == INSERT_SORT )
		sort = InsertSort&;
			
	else if ( choice == MERGE_SORT )
		sort = MergeSort&;

	else if ( choice == QUICK_SORT )
		sort = QuickSort&;

	else if ( choice == SELECT_SORT )
		sort = SelectSort&;
		
	else if ( choice == SHELL_SORT )
		sort = ShellSort&;
		
	return;
}

// -----------------------------------------------------------------------------
// FUNCTION : RunSortTests
// IMPLEMENTED BY: Ian Huckaby
// DESCRIPTION:		overall control of sort testing
// INPUTS:
//		Parameters:
//				sort1			- pointer to first sort function
//				sort2			- pointer to second sort function
//				repsCount		- number of repetitions to test each sort
// OUTPUTS:
//		Returns:
//				isValid			- validity of input
// CALLS TO:
//				FillArrays
//				TimeSort
//				ComputeResults
// -----------------------------------------------------------------------------
bool RunSortTests ( funcPtr sort1 , funcPtr sort2 , int repsCount )
{
	//local variables
	bool exitProg = false;
	int* timeArray1;			// creating arrays to hold timing results
	int* timeArray2;
	int randArray1[ARRAY_SIZE];	// arrays to fill and sort
	int randArray2[ARRAY_SIZE];
	int result1 = 1;			// checking validity of each sort
	int result2 = 1;
	int testNum = 1;
	
	// create the arrays to hold results
	timeArray1 = new (nothrow) int [repsCount];
	timeArray2 = new (nothrow) int [repsCount];
	
	// need to validate array creation
	
	// perform a test for each "repsCount"
	for ( int counter = 0 ; counter < repsCount && !exitProg ; counter++ )
	{
		// fill the arrays to sort with random numbers
		FillArrays ( randArray1 , randArray2 );
		
		// display sort number
		cout << "Starting sort #" << testNum++ << endl << endl;
	
		// sort the two arrays, holding the results
		result1 = TimeSort(sort1 , randArray1);
		result2 = TimeSort(sort2 , randArray2);
		
		// check for a valid result (timeSort returns 0 if fails)
		if ( !result1 || !result2 )
		{
			cout << "ERROR: Sort validation failed" << endl;
			exitProg = true;
		}
			
		else 	// valid results, add to arrays
		{
			// display success
			cout << "         Sorts validated" << endl << endl;
			
			// add to arrays
			timeArray1[counter] = result1;
			timeArray2[counter] = result2;
		}
		
	} // end for
	
	// if sorts completed successfully, output
	if (!exitProg)
		ComputeResults ( timeArray1 , timeArray2 , repsCount ,\
						AssignString( sort1 ) , AssignString( sort2 ) );
						
	// deallocate arrays
	delete timeArray1;
	delete timeArray2;
	
	return exitProg;
}
	
// -----------------------------------------------------------------------------
// FUNCTION : FillArrays
// IMPLEMENTED BY: Ian Huckaby
// DESCRIPTION:		fills two arrays passed to it with ARRAY_SIZE random
//					 integers generated by the GetRandNum function
//					NOTE: the two arrays are filled with the same integers, they
//							are identical when leaving the function
// OUTPUTS:
//		Parameters:
//				randArray1		- populated first array
//				randArray2		- populated second array
// CALLS TO:
//				GetRandNum
// -----------------------------------------------------------------------------
void FillArrays ( int randArray1[] , int randArray2[] )
{
	// local variables
	int randNum;		// for holding generated numbers
	
	for ( int idx = 0 ; idx < ARRAY_SIZE ; idx++ )
	{
		// get a random number in range
		randNum = GetRandNum();
		
		// put the number in both arrays
		randArray1[idx] = randNum;
		randArray2[idx] = randNum;
		
	} // end for
	
	return;
}

// -----------------------------------------------------------------------------
// FUNCTION : GetRandNum
// IMPLEMENTED BY: Ian Huckaby
// DESCRIPTION:		generates a random integer between RAND_ARRAY_BOTTOM
//					 and RAND_ARRAY_TOP
// OUTPUTS:
//		Returns:
//				randNum			- generated random number
// -----------------------------------------------------------------------------
int GetRandNum ()
{
	// local variables
	int randNum = 0;			// randomly generated number to return
	
	// seed the random number generator with time
	// don't do this until after code testing is done
	// srand(time(0));
	
	randNum = (rand() % RAND_ARRAY_TOP) + RAND_ARRAY_BOTTOM;
	
	return randNum;
}

// -----------------------------------------------------------------------------
// FUNCTION : BubbleSort
// IMPLEMENTED BY: Ian Huckaby
// DESCRIPTION:		bubble sort array
// INPUTS:
//		Parameters:
//				arrayToSort		- array to sort
//				arraySize		- max index in array
//				junk			- our function pointers need two integers, this
//									function only needs one
// OUTPUTS:
//		Parameters:
//				arrayToSort		- sorted array
// -----------------------------------------------------------------------------
void BubbleSort ( int arrayToSort[] , int arraySize , int junk )
{
	// local variables
	bool sortDone = false;	// for flagging finish
	int inner, outer;		// loop counters for walking the array
	int temp;				// holding variable
	
	for ( outer = 0 ; (outer < arraySize) && !sortDone ; outer++ )
	{
		// assume we're done until swap is made
		sortDone = true;
		
		// sorting passes, lowering number each time because the last item will
		// be in the correct position
		for ( inner = 0 ; inner < (arraySize - 1) ; inner++ )
		{
			// if next element less than current
			if (arrayToSort[inner + 1] < arrayToSort[inner])
			{
				// swap elements
				temp = arrayToSort[inner];
				arrayToSort[inner] = arrayToSort[inner + 1];
				arrayToSort[inner + 1] = temp;
				sortDone = false;
			}
		} // end inner for
	} // end outer for
		
	return;
}

// -----------------------------------------------------------------------------
// FUNCTION : ShellSort
// IMPLEMENTED BY: Ian Huckaby
// DESCRIPTION:		shell sort array
// INPUTS:
//		Parameters:
//				arrayToSort		- array to sort
//				arraySize		- number of elements in array
//				junk			- funtion pointer needs three arugments
// OUTPUTS:
//		Parameters:
//				arrayToSort		- sorted array
// -----------------------------------------------------------------------------
void ShellSort ( int arrayToSort[] , int arraySize , int junk)
{
	//local variables
	int gap = arraySize;		// for tracking step size of sort
	bool sorted = false;		// for detecting a run with no swaps
	int idx;					// index
	int test;					// element to compare
	int value;					// value to compare/insert
	int 
	
	while ( !sorted || (gap > 1)
	{
		sorted = true; 			// assume this was last until swap is made
		gap /= 2;				// halve the stepping size
		idx = gap;				// set item to sort
		
		while ( idx < arraySize )
		{
			if ( (idx - gap) > 0 && arrayToSort[idx] < 
		
// -----------------------------------------------------------------------------
// FUNCTION : ComputeResults
// IMPLEMENTED BY: Ian Huckaby
// DESCRIPTION:		takes two arrays of timing results and computes summary info
// INPUTS:
//		Parameters:
//				timeArray1		- timings of first sort method
//				timeArray2		- timings of second sort method
//				arraySize		- size of time arrays (number of sort tests)
//				sortFn1			- name of first sort method
//				sortFn2			- name of second sort method
// CALLS TO:
//				DisplayResults
// -----------------------------------------------------------------------------
void ComputeResults ( int timeArray1[] , int timeArray2[] , int arraySize ,\
						string sortFn1 , string sortFn2 )
{
	// local variables
	double test1Avg = 0;		// holding average of array 1
	double test2Avg = 0;		// holding average of array 2
	int sum1 = 0;				// running total of array 1
	int sum2 = 0;				// running total of array 2
	
	// sum values in arrays
	for ( int idx = 0 ; idx < arraySize ; idx++ )
	{
		sum1 += timeArray1[idx];
		sum2 += timeArray2[idx];
	}
	
	// compute averages
	test1Avg = (static_cast<double>(sum1)) / arraySize;
	test2Avg = (static_cast<double>(sum2)) / arraySize;
	
	// output to screen
	DisplayResults ( test1Avg , test2Avg , sortFn1 , sortFn2 );
	
	return;
}

// -----------------------------------------------------------------------------
// FUNCTION : DisplayResults
// IMPLEMENTED BY: Ian Huckaby
// DESCRIPTION:		outputs summary info from ComputeResults
// INPUTS:
//		Parameters:
//				test1Avg		- average of first sort test timings
//				test2Avg		- average of second sort test timings
//				sort1			- name of first sort method
//				sort2			- name of second sort method
// -----------------------------------------------------------------------------
void DisplayResults ( double test1Avg , double test2Avg , string sort1 , string sort2 )
{	
	cout << showpoint << fixed << setprecision(1);
	cout << "SORTING RESULTS" << endl
		 << "---------------" << endl
		 << right << setw(20) << sort1 << setw(12) << test1Avg
			<< "clock ticks on average" << endl
		 << setw(20) << sort2 << setw(12) << test2Avg
			<< "clock ticks on average" << endl
		<< endl;
		
	system("pause");
	
	return;
}